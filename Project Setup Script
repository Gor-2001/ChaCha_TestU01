# ChaCha/PRNG Comparison Project - Documentation and Plan

## Project Overview

A benchmarking system to compare cryptographic stream ciphers (ChaCha variants) against traditional PRNGs (PCG, LCG) using the TestU01 statistical test suite. The goal is to generate comprehensive test results and beautiful visualizations showing performance and statistical quality differences.

## RNG Implementations (7 total)

### Traditional PRNGs
1. **PCG** - Permuted Congruential Generator
2. **LCG** - Linear Congruential Generator

### ChaCha Variants (Standard Counter Mode)
3. **ChaCha20** - 20 rounds, standard stream cipher mode
4. **ChaCha12** - 12 rounds (reduced)
5. **ChaCha8** - 8 rounds (reduced)
6. **ChaCha4** - 4 rounds (reduced)

### ChaCha Experimental Mode
7. **ChaCha4-Feedback** - 4 rounds with output feedback
   - Instead of incrementing counter, feed the output of block N as the seed/state for block N+1
   - This is NOT standard counter mode - it's a custom feedback mechanism

## Testing Framework

### TestU01 Test Suites
All RNGs will be tested through three TestU01 batteries:
- **SmallCrush** - 15 tests, approximately 1 second runtime
- **Crush** - 144 tests, approximately 30 minutes runtime
- **BigCrush** - 160 tests, approximately 4 hours runtime

### Test Execution
Each RNG runs through each test suite independently, producing separate result files.

Total test runs: 7 RNGs × 3 suites = 21 result files

## Build System

### Technology Stack
- **Language**: C (implementation), Python (visualization)
- **Build System**: CMake
- **Platform**: Linux (Ubuntu)
- **Compiler**: GCC
- **External Library**: TestU01

### Project Structure
```
chacha_prng_bench/
├── src/
│   ├── chacha/           # ChaCha implementations
│   │   ├── chacha_core.c          # Shared ChaCha core (quarter round, etc)
│   │   ├── chacha20.c             # 20-round variant
│   │   ├── chacha12.c             # 12-round variant
│   │   ├── chacha8.c              # 8-round variant
│   │   ├── chacha4.c              # 4-round variant
│   │   ├── chacha4_feedback.c     # 4-round feedback mode
│   │   └── chacha.h               # ChaCha headers
│   ├── prng/             # PRNG implementations
│   │   ├── pcg.c
│   │   ├── lcg.c
│   │   └── prng.h
│   ├── tests/            # TestU01 integration
│   │   ├── testu01_wrapper.c      # Wrapper for TestU01 batteries
│   │   ├── benchmark.c            # Performance benchmarking
│   │   ├── runner.c               # Test execution logic
│   │   └── tests.h
│   └── main.c            # Entry point
├── python/               # Visualization tools
│   ├── plotter.py                 # Generate comparison charts
│   ├── analyzer.py                # Statistical analysis
│   ├── compare.py                 # Compare arbitrary result files
│   └── __init__.py
├── include/              # Headers
│   ├── common.h                   # Common definitions
│   └── rng_interface.h            # Unified RNG interface
├── results/              # Test output directory
│   └── (CSV files generated here)
├── scripts/              # Automation scripts
│   ├── run_all_tests.sh           # Run all combinations
│   └── run_single.sh              # Run specific RNG+suite
├── build/                # CMake build directory
├── CMakeLists.txt        # Build configuration
├── README.md             # User documentation
├── requirements.txt      # Python dependencies
└── .gitignore
```

## Results Format

### File Naming Convention
Pattern: `<rng_name>_<test_suite>.csv`

Examples:
- `pcg_smallcrush.csv`
- `chacha20_bigcrush.csv`
- `chacha4_feedback_crush.csv`

### CSV Structure
Each result file contains:
1. **Test Results** (one row per statistical test)
   - Test name
   - p-value (if applicable)
   - Pass/Fail status
   - Additional notes

2. **Metadata** (at end of file)
   - Total execution time (seconds)
   - Throughput (MB/s)
   - Timestamp
   - RNG configuration details

## Execution Flow

### Phase 1: Build
```
mkdir build && cd build
cmake ..
make
```

### Phase 2: Run Tests
Option A: Run all tests (automated)
```
./scripts/run_all_tests.sh
```

Option B: Run specific test
```
./build/rng_bench <rng_name> <test_suite>
```

Available RNG names:
- pcg
- lcg
- chacha20
- chacha12
- chacha8
- chacha4
- chacha4_feedback

Available test suites:
- smallcrush
- crush
- bigcrush

### Phase 3: Visualization
Compare arbitrary number of result files:
```
python3 python/compare.py results/*.csv
python3 python/plotter.py results/chacha20_bigcrush.csv results/pcg_bigcrush.csv
```

## Visualization Requirements

### Key Features
- **Beautiful, clear graphics** - primary goal is visual clarity
- **Arbitrary file comparison** - ability to select and compare any subset of result files
- **Multiple chart types**:
  - Pass/fail rates across RNGs
  - Performance comparison (throughput)
  - Statistical quality metrics
  - Per-test detailed comparison

### Python Visualization Tools
1. **plotter.py** - Generate individual comparison charts
2. **compare.py** - Comprehensive comparison across multiple RNGs
3. **analyzer.py** - Deep statistical analysis of results

## Implementation Plan

### Step 1: Project Setup (CURRENT STEP)
Generate directory structure and placeholder files using setup script.
NO actual implementation code yet.

### Step 2: Core C Implementation
- Implement common RNG interface
- Implement ChaCha core functionality
- Implement all 7 RNG variants
- Create TestU01 wrapper functions

### Step 3: Test Integration
- Integrate SmallCrush/Crush/BigCrush
- Implement result file generation (CSV format)
- Add performance benchmarking
- Create test runner logic

### Step 4: Python Visualization
- Implement CSV parsing
- Create plotting functions
- Design chart layouts for clarity
- Implement comparison tools

### Step 5: Automation
- Create shell scripts for batch testing
- Add documentation
- Test full workflow

## Key Design Decisions

### RNG Interface
All RNGs implement a uniform interface:
- Initialization with seed
- Generate next 32-bit value
- Generate next 64-bit value
- State reset capability

### ChaCha4-Feedback Details
Standard ChaCha uses counter mode: state = (key, nonce, counter++)

ChaCha4-Feedback mode:
- Block 0: state = (initial_key, nonce, initial_counter)
- Block 1: state = (output_block_0, nonce, counter)
- Block 2: state = (output_block_1, nonce, counter)
- And so on...

The output of each block becomes the key material for the next block.

### Performance Metrics
Each test measures:
- Statistical test pass rate
- Throughput (bytes generated per second)
- Execution time for full test suite

## Expected Outcomes

### Hypothesis
- ChaCha20 should pass all tests with highest security margin
- Reduced-round ChaCha variants may show weaknesses in BigCrush
- ChaCha4-Feedback may exhibit different statistical properties than counter mode
- PCG should perform well, LCG should show statistical weaknesses
- Performance should decrease with increased rounds (ChaCha4 > ChaCha20)

### Deliverables
1. Complete test results for all 7 RNGs × 3 test suites
2. Comparative visualization showing:
   - Statistical quality ranking
   - Performance ranking
   - Trade-off analysis (speed vs. quality)
3. Analysis of ChaCha4-Feedback vs ChaCha4 standard mode